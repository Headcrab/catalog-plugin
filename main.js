/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// main.ts
__export(exports, {
  default: () => CatalogPlugin
});
var import_obsidian2 = __toModule(require("obsidian"));

// CatalogView.ts
var import_obsidian = __toModule(require("obsidian"));
var VIEW_TYPE_CATALOG = "catalog-view";
var CatalogView = class extends import_obsidian.ItemView {
  constructor(leaf, settings) {
    super(leaf);
    this.allItems = [];
    this.currentPage = 1;
    this.itemsPerPage = 10;
    this.currentSortColumn = null;
    this.currentSortOrder = "asc";
    this.settings = settings;
  }
  getViewType() {
    return VIEW_TYPE_CATALOG;
  }
  getDisplayText() {
    return "\u041A\u0430\u0442\u0430\u043B\u043E\u0433 \u0442\u043E\u0432\u0430\u0440\u043E\u0432";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.createEl("h4", { text: "\u041A\u0430\u0442\u0430\u043B\u043E\u0433 \u0442\u043E\u0432\u0430\u0440\u043E\u0432" });
    await this.renderCatalog(container);
  }
  async onClose() {
  }
  async renderCatalog(container) {
    const mainContainer = container.createEl("div", { cls: "catalog-container" });
    mainContainer.createEl("h4", { text: "\u041A\u0430\u0442\u0430\u043B\u043E\u0433 \u0442\u043E\u0432\u0430\u0440\u043E\u0432", cls: "catalog-title" });
    this.allItems = await this.getAllItems(this.settings.filenames);
    if (this.allItems.length === 0) {
      mainContainer.createEl("p", { text: "\u041F\u0440\u0435\u0434\u0443\u043F\u0440\u0435\u0436\u0434\u0435\u043D\u0438\u0435: \u0412 \u0437\u0430\u043C\u0435\u0442\u043A\u0430\u0445 \u043A\u0430\u0442\u0430\u043B\u043E\u0433\u0430 \u0442\u043E\u0432\u0430\u0440\u043E\u0432 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u043E \u0434\u0430\u043D\u043D\u044B\u0445 \u0432 \u043E\u0436\u0438\u0434\u0430\u0435\u043C\u043E\u043C \u0444\u043E\u0440\u043C\u0430\u0442\u0435." });
      return;
    }
    const controls = this.createControls(mainContainer);
    const tableContainer = mainContainer.createEl("div");
    this.updateTable(tableContainer);
    controls.applyFilterButton.addEventListener("click", () => this.updateTable(tableContainer));
    controls.resetFilterButton.addEventListener("click", () => this.resetFilters(mainContainer, tableContainer));
    controls.itemsPerPageSelect.addEventListener("change", () => {
      this.itemsPerPage = parseInt(controls.itemsPerPageSelect.value);
      this.currentPage = 1;
      this.updateTable(tableContainer);
    });
    controls.prevButton.addEventListener("click", () => {
      if (this.currentPage > 1) {
        this.currentPage--;
        this.updateTable(tableContainer);
      }
    });
    controls.nextButton.addEventListener("click", () => {
      const totalPages = Math.ceil(this.getFilteredItems().length / this.itemsPerPage);
      if (this.currentPage < totalPages) {
        this.currentPage++;
        this.updateTable(tableContainer);
      }
    });
  }
  async getAllItems(filenames) {
    const allItems = [];
    for (const filename of filenames) {
      const files = this.app.vault.getMarkdownFiles().filter((file) => this.matchesMask(file.name, filename));
      for (const file of files) {
        const content = await this.app.vault.read(file);
        const items = this.parseItems(content, file.path);
        allItems.push(...items);
      }
    }
    return allItems;
  }
  createControls(container) {
    const controlsContainer = container.createEl("div", { cls: "catalog-controls" });
    const inputStyle = "catalog-filter-input";
    const allFields = this.getAllFields();
    const filterFields = this.settings.filterFields;
    const fieldsToFilter = filterFields.length > 0 ? allFields.filter((field) => filterFields.includes(field)) : allFields;
    fieldsToFilter.forEach((field) => {
      controlsContainer.createEl("input", {
        attr: {
          type: "text",
          placeholder: `\u0424\u0438\u043B\u044C\u0442\u0440 \u043F\u043E ${field.toLowerCase()}`,
          class: inputStyle
        }
      });
    });
    const buttonStyle = "catalog-button";
    const applyFilterButton = controlsContainer.createEl("button", { cls: buttonStyle });
    applyFilterButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon></svg>`;
    const resetFilterButton = controlsContainer.createEl("button", { cls: buttonStyle });
    resetFilterButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2.5 2v6h6M2.66 15.57a10 10 0 1 0 .57-8.38"/></svg>`;
    const paginationContainer = controlsContainer.createEl("div", { cls: "catalog-pagination" });
    const itemsPerPageSelect = paginationContainer.createEl("select", { cls: "catalog-items-per-page" });
    [5, 10, 20, 50, 100].forEach((value) => {
      itemsPerPageSelect.createEl("option", { text: value.toString(), value: value.toString() });
    });
    itemsPerPageSelect.value = this.itemsPerPage.toString();
    const prevButton = paginationContainer.createEl("button", { text: "\u2190", cls: buttonStyle });
    const pageInfo = paginationContainer.createEl("span", {
      text: `\u0421\u0442\u0440\u0430\u043D\u0438\u0446\u0430 ${this.currentPage}`,
      cls: "catalog-pagination-info"
    });
    const nextButton = paginationContainer.createEl("button", { text: "\u2192", cls: buttonStyle });
    return { applyFilterButton, resetFilterButton, itemsPerPageSelect, prevButton, pageInfo, nextButton };
  }
  updateTable(tableContainer) {
    tableContainer.empty();
    const filteredItems = this.getFilteredItems();
    const paginatedItems = this.paginateItems(filteredItems);
    const table = tableContainer.createEl("table", { cls: "catalog-table" });
    const thead = table.createEl("thead");
    const headerRow = thead.createEl("tr");
    const columnWidth = `${100 / this.settings.keys.length}%`;
    this.settings.keys.forEach((header) => {
      const th = headerRow.createEl("th", {
        text: header,
        attr: {
          style: `background-color: #3a3a3a; color: #e0e0e0; padding: 12px; text-align: left; font-weight: bold; cursor: pointer; width: ${columnWidth}; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;`
        }
      });
      th.addEventListener("click", () => this.sortTable(header));
    });
    const tbody = table.createEl("tbody");
    paginatedItems.forEach((item, index) => {
      const row = tbody.createEl("tr", { attr: { style: `background-color: ${index % 2 === 0 ? "#2c2c2c" : "#333333"};` } });
      this.settings.keys.forEach((key) => {
        const cell = row.createEl("td", { attr: { style: `padding: 12px; border-top: 1px solid #444; width: ${columnWidth}; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;` } });
        const values = item[key];
        if (Array.isArray(values)) {
          values.forEach((value, index2) => {
            if (index2 > 0) {
              cell.appendChild(document.createTextNode(", "));
            }
            this.createLinkOrText(cell, value, value);
          });
        } else if (typeof values === "string" || typeof values === "number") {
          this.createLinkOrText(cell, values.toString(), values.toString());
        } else {
          cell.appendChild(document.createTextNode("-\u043D\u0435\u0442-"));
        }
      });
    });
    const totalPages = Math.ceil(filteredItems.length / this.itemsPerPage);
    const pageInfo = this.containerEl.querySelector(".catalog-pagination-info");
    if (pageInfo) {
      pageInfo.textContent = `\u0421\u0442\u0440\u0430\u043D\u0438\u0446\u0430 ${this.currentPage} \u0438\u0437 ${totalPages}`;
    }
  }
  getFilteredItems() {
    const filters = this.getFilters();
    return this.allItems.filter((item) => Object.entries(filters).every(([key, value]) => {
      if (!value)
        return true;
      const itemValue = item[key];
      if (Array.isArray(itemValue)) {
        return itemValue.some((v) => v.toLowerCase().includes(value.toLowerCase()));
      } else if (typeof itemValue === "string" || typeof itemValue === "number") {
        return itemValue.toString().toLowerCase().includes(value.toLowerCase());
      }
      return false;
    }));
  }
  getFilters() {
    return Object.fromEntries(this.settings.keys.map((key) => {
      var _a;
      return [key, ((_a = this.containerEl.querySelector(`input[placeholder="\u0424\u0438\u043B\u044C\u0442\u0440 \u043F\u043E ${key.toLowerCase()}"]`)) == null ? void 0 : _a.value) || ""];
    }));
  }
  paginateItems(items) {
    const start = (this.currentPage - 1) * this.itemsPerPage;
    const end = start + this.itemsPerPage;
    return items.slice(start, end);
  }
  resetFilters(mainContainer, tableContainer) {
    this.settings.keys.forEach((key) => {
      const filterInput = mainContainer.querySelector(`input[placeholder="\u0424\u0438\u043B\u044C\u0442\u0440 \u043F\u043E ${key.toLowerCase()}"]`);
      if (filterInput) {
        filterInput.value = "";
      }
    });
    this.currentSortColumn = null;
    this.currentSortOrder = "asc";
    this.currentPage = 1;
    this.updateTable(tableContainer);
  }
  sortTable(column) {
    if (this.currentSortColumn === column) {
      this.currentSortOrder = this.currentSortOrder === "asc" ? "desc" : "asc";
    } else {
      this.currentSortColumn = column;
      this.currentSortOrder = "asc";
    }
    this.allItems.sort((a, b) => {
      const valueA = this.getSortValue(a[column]);
      const valueB = this.getSortValue(b[column]);
      return this.currentSortOrder === "asc" ? valueA.localeCompare(valueB) : valueB.localeCompare(valueA);
    });
    this.updateTable(this.containerEl.children[1].querySelector("div"));
  }
  getSortValue(value) {
    if (Array.isArray(value)) {
      return value[0] || "";
    } else if (typeof value === "string" || typeof value === "number") {
      return value.toString().replace(/^\[\[|\]\]$/g, "");
    }
    return "";
  }
  matchesMask(filename, mask) {
    const regexPattern = mask.replace(/\*/g, ".*").replace(/\?/g, ".");
    const regex = new RegExp(`^${regexPattern}$`, "i");
    return regex.test(filename);
  }
  parseItems(content, filePath) {
    const items = [];
    let currentItem = {};
    let lineNumber = 0;
    content.split("\n").forEach((line) => {
      lineNumber++;
      if (line.startsWith("- \u0422\u043E\u0432\u0430\u0440")) {
        if (Object.keys(currentItem).length > 0) {
          items.push(currentItem);
        }
        currentItem = { lineNumber, filePath };
      } else if (line.trim().startsWith("- ")) {
        const [key, ...valueParts] = line.split(":").map((s) => s.trim());
        const cleanKey = key.replace("- ", "");
        if (this.settings.keys.includes(cleanKey)) {
          currentItem[cleanKey] = valueParts.join(":").trim().split(",").map((v) => v.trim());
        }
      }
    });
    if (Object.keys(currentItem).length > 0) {
      items.push(currentItem);
    }
    return items;
  }
  async createLinkOrText(container, value, displayText) {
    if (value.startsWith("#")) {
      container.createEl("a", {
        text: value,
        attr: {
          class: "tag",
          href: value,
          style: "text-decoration: none; border-radius: 4px; padding: 2px 4px; font-size: 0.9em; font-weight: 500;"
        }
      });
      return;
    }
    let filePath, linkText, isMedia = false;
    if (value.startsWith("![[") && value.endsWith("]]")) {
      isMedia = true;
      filePath = value.slice(3, -2);
    } else if (value.match(/\[.*?\]\(.*?\)/)) {
      const match = value.match(/\[(.*?)\]\((.*?)\)/);
      if (match) {
        [, linkText, filePath] = match;
        filePath = decodeURIComponent(filePath);
      }
    } else if (value.startsWith("[[") && value.endsWith("]]")) {
      const parts = value.slice(2, -2).split("|").map((s) => s.trim());
      filePath = parts[0];
      linkText = parts[1] || parts[0];
      isMedia = filePath ? [".png", ".jpg", ".jpeg", ".gif", ".svg", ".webp"].some((ext) => filePath.toLowerCase().endsWith(ext)) : false;
    } else {
      container.appendChild(document.createTextNode(value));
      return;
    }
    linkText = linkText || (filePath == null ? void 0 : filePath.replace(/\.md$/, ""));
    filePath = filePath == null ? void 0 : filePath.replace(/^\//, "");
    if (filePath) {
      let file = this.app.vault.getAbstractFileByPath(filePath);
      if (!file && !filePath.endsWith(".md")) {
        file = this.app.vault.getAbstractFileByPath(filePath + ".md");
      }
      if (isMedia && file instanceof import_obsidian.TFile) {
        const imgElement = container.createEl("img", {
          cls: "catalog-image",
          attr: {
            src: this.app.vault.getResourcePath(file),
            alt: linkText || ""
          }
        });
        imgElement.addEventListener("click", (event) => {
          event.preventDefault();
          event.stopPropagation();
          this.openImageModal(file);
        });
      } else {
        const linkElement = container.createEl("a", {
          text: linkText || "",
          cls: "catalog-link",
          attr: {
            href: filePath
          }
        });
        linkElement.addEventListener("click", (event) => {
          event.preventDefault();
          if (file instanceof import_obsidian.TFile) {
            this.app.workspace.openLinkText(file.path, "", false);
          } else if (filePath) {
            this.app.workspace.openLinkText(filePath, "", true);
          }
        });
      }
    }
  }
  openImageModal(file) {
    new ImageModal(this.app, file).open();
  }
  updateSettings(newSettings) {
    this.settings = newSettings;
    this.reloadCatalog();
    this.loadCustomCSS();
  }
  async reloadCatalog() {
    this.allItems = await this.getAllItems(this.settings.filenames);
    const container = this.containerEl.children[1];
    container.empty();
    await this.renderCatalog(container);
  }
  async loadCustomCSS() {
    if (this.settings.cssFile) {
      const file = this.app.vault.getAbstractFileByPath(this.settings.cssFile);
      if (file instanceof import_obsidian.TFile) {
        const content = await this.app.vault.read(file);
        const styleEl = document.getElementById("catalog-plugin-styles");
        if (styleEl) {
          styleEl.textContent = content;
        }
      }
    }
  }
  getAllFields() {
    const allFields = new Set();
    this.allItems.forEach((item) => {
      Object.keys(item).forEach((key) => {
        allFields.add(key);
      });
    });
    return Array.from(allFields);
  }
};
var ImageModal = class extends import_obsidian.Modal {
  constructor(app, file) {
    super(app);
    this.file = file;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("image-preview-modal");
    const img = contentEl.createEl("img", {
      attr: {
        src: this.app.vault.getResourcePath(this.file),
        alt: this.file.name
      }
    });
    img.addEventListener("load", () => {
      const aspectRatio = img.naturalWidth / img.naturalHeight;
      const maxWidth = window.innerWidth * 0.8;
      const maxHeight = window.innerHeight * 0.8;
      if (aspectRatio > maxWidth / maxHeight) {
        img.style.width = maxWidth + "px";
        img.style.height = "auto";
      } else {
        img.style.width = "auto";
        img.style.height = maxHeight + "px";
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  filenames: ["\u041A\u0430\u0442\u0430\u043B\u043E\u0433 \u0442\u043E\u0432\u0430\u0440\u043E\u0432*", "\u041F\u0440\u0438\u043C\u0435\u0440*"],
  keys: ["\u041D\u0430\u0437\u0432\u0430\u043D\u0438\u0435", "\u0426\u0432\u0435\u0442", "\u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435"],
  preview_size: 100,
  cssFile: "",
  filterFields: []
};
var CatalogPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.catalogView = null;
  }
  async onload() {
    await this.loadSettings();
    this.registerView(VIEW_TYPE_CATALOG, (leaf) => {
      this.catalogView = new CatalogView(leaf, this.settings);
      return this.catalogView;
    });
    this.addRibbonIcon("book", "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u043A\u0430\u0442\u0430\u043B\u043E\u0433", () => {
      this.activateView();
    });
    this.addSettingTab(new CatalogSettingTab(this.app, this));
    this.loadStyles();
  }
  async onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_CATALOG);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.updateCatalogView();
  }
  updateCatalogView() {
    var _a;
    const catalogView = (_a = this.app.workspace.getLeavesOfType("catalog-view")[0]) == null ? void 0 : _a.view;
    if (catalogView) {
      catalogView.reloadCatalog();
    }
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(VIEW_TYPE_CATALOG)[0];
    if (!leaf) {
      const newLeaf = workspace.getRightLeaf(false);
      if (newLeaf) {
        await newLeaf.setViewState({ type: VIEW_TYPE_CATALOG, active: true });
        leaf = newLeaf;
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  reloadStyles() {
    this.loadStyles();
  }
  loadStyles() {
    const styleEl = document.createElement("style");
    styleEl.id = "catalog-plugin-styles";
    document.head.appendChild(styleEl);
    if (this.settings.cssFile) {
      this.loadCustomCSS(this.settings.cssFile);
    } else {
      styleEl.textContent = `
                .image-preview-modal {
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    padding: 20px;
                }

                .image-preview-modal img {
                    max-width: 100%;
                    max-height: 100%;
                    object-fit: contain;
                }
            `;
    }
  }
  async loadCustomCSS(cssPath) {
    const file = this.app.vault.getAbstractFileByPath(cssPath);
    if (file instanceof import_obsidian2.TFile) {
      const content = await this.app.vault.read(file);
      const styleEl = document.getElementById("catalog-plugin-styles");
      if (styleEl) {
        styleEl.textContent = content;
      }
    }
  }
};
var CatalogSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u043A\u0430\u0442\u0430\u043B\u043E\u0433\u0430 \u0442\u043E\u0432\u0430\u0440\u043E\u0432" });
    new import_obsidian2.Setting(containerEl).setName("\u041C\u0430\u0441\u043A\u0438 \u0444\u0430\u0439\u043B\u043E\u0432").setDesc("\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043C\u0430\u0441\u043A\u0438 \u0444\u0430\u0439\u043B\u043E\u0432, \u0440\u0430\u0437\u0434\u0435\u043B\u0435\u043D\u043D\u044B\u0435 \u0437\u0430\u043F\u044F\u0442\u043E\u0439").addText((text) => text.setPlaceholder("\u041A\u0430\u0442\u0430\u043B\u043E\u0433 \u0442\u043E\u0432\u0430\u0440\u043E\u0432*, \u041F\u0440\u0438\u043C\u0435\u0440*").setValue(this.plugin.settings.filenames.join(", ")).onChange(async (value) => {
      this.plugin.settings.filenames = value.split(",").map((s) => s.trim());
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("\u041A\u043B\u044E\u0447\u0438").setDesc("\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043A\u043B\u044E\u0447\u0438 (\u0441\u0442\u043E\u043B\u0431\u0446\u044B) \u0434\u043B\u044F \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u044F, \u0440\u0430\u0437\u0434\u0435\u043B\u0435\u043D\u043D\u044B\u0435 \u0437\u0430\u043F\u044F\u0442\u043E\u0439").addText((text) => text.setPlaceholder("\u041D\u0430\u0437\u0432\u0430\u043D\u0438\u0435, \u0426\u0432\u0435\u0442, \u0418\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435").setValue(this.plugin.settings.keys.join(", ")).onChange(async (value) => {
      this.plugin.settings.keys = value.split(",").map((s) => s.trim());
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("\u0420\u0430\u0437\u043C\u0435\u0440 \u043F\u0440\u0435\u0434\u043F\u0440\u043E\u0441\u043C\u043E\u0442\u0440\u0430").setDesc("\u0423\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u0435 \u0440\u0430\u0437\u043C\u0435\u0440 \u043F\u0440\u0435\u0434\u043F\u0440\u043E\u0441\u043C\u043E\u0442\u0440\u0430 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0439 (\u0432 \u043F\u0438\u043A\u0441\u0435\u043B\u044F\u0445)").addSlider((slider) => slider.setLimits(50, 300, 10).setValue(this.plugin.settings.preview_size).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.preview_size = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("CSS \u0444\u0430\u0439\u043B").setDesc("\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 CSS \u0444\u0430\u0439\u043B \u0434\u043B\u044F \u0441\u0442\u0438\u043B\u0438\u0437\u0430\u0446\u0438\u0438 \u043A\u0430\u0442\u0430\u043B\u043E\u0433\u0430").addDropdown((dropdown) => {
      const cssFiles = this.getCSSFiles();
      cssFiles.unshift("");
      dropdown.addOptions(Object.fromEntries(cssFiles.map((file) => [file, file || "\u041F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E"]))).setValue(this.plugin.settings.cssFile).onChange(async (value) => {
        this.plugin.settings.cssFile = value;
        await this.plugin.saveSettings();
        this.plugin.reloadStyles();
      });
    });
    new import_obsidian2.Setting(containerEl).setName("\u041F\u043E\u043B\u044F \u0434\u043B\u044F \u0444\u0438\u043B\u044C\u0442\u0440\u0430\u0446\u0438\u0438").setDesc("\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u044F \u043F\u043E\u043B\u0435\u0439 \u0447\u0435\u0440\u0435\u0437 \u0437\u0430\u043F\u044F\u0442\u0443\u044E. \u041E\u0441\u0442\u0430\u0432\u044C\u0442\u0435 \u043F\u0443\u0441\u0442\u044B\u043C \u0434\u043B\u044F \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u044F \u0432\u0441\u0435\u0445 \u043F\u043E\u043B\u0435\u0439.").addText((text) => text.setPlaceholder("\u043F\u043E\u043B\u04351,\u043F\u043E\u043B\u04352,\u043F\u043E\u043B\u04353").setValue(this.plugin.settings.filterFields.join(",")).onChange(async (value) => {
      this.plugin.settings.filterFields = value.split(",").map((field) => field.trim()).filter((field) => field !== "");
      await this.plugin.saveSettings();
      this.plugin.updateCatalogView();
    }));
  }
  getCSSFiles() {
    const cssFiles = [];
    const searchCSSFiles = (folder) => {
      for (const child of folder.children) {
        if (child instanceof import_obsidian2.TFile && child.extension === "css") {
          cssFiles.push(child.path);
        } else if (child instanceof import_obsidian2.TFolder) {
          searchCSSFiles(child);
        }
      }
    };
    searchCSSFiles(this.app.vault.getRoot());
    return cssFiles;
  }
};
